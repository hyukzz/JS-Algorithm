## 문제 정의

1. 두 수를 입력받아 거듭제곱을 리턴한다.

## 입력

인자 1: base
number 타입의 자연수 (base >= 2)

인자 2: exponent
number 타입의 정수 (exponent >= 0)

## 출력

1. number 타입을 리턴한다.
2. 실제 계산 결과를 94,906,249로 나눈 나머지를 리턴한다.

## 주의사항

1. Math.pow, 거듭제곱 연산자 사용은 금지된다.
2. 시간복잡도 O(logN)을 만족해야 한다.
3. 나머지를 구하는 이유는 계산 결과가 컴퓨터로 나타낼 수 있는 수의 범위를 넘을 수 있기 때문이다. 하지만 모든 연산이 끝난 뒤에 그 결과를 94,906,249로 나누려고 해서는 안 된다. 연산 중간에도 이 범위를 넘을 수 있기 때문에, 연산을 할 때마다 나머지를 구하고 그 결과에 연산을 이어가야한다.


## 입출력 예시

```
let output = power(3, 40);
console.log(output); // --> 19334827
```

## 문제 풀이

1. 지수가 0일 때는 어떤 베이스의 수가 와도 1이 되기 때문에 1을 리턴시킨다.
2. 시간복잡도에 따라 전체를 반으로 나누고 나머지 소수점은 날린다.
3. 반으로 나눈 temp라는 변수를 만든다.
4. temp끼리 곱하여 기존에 거듭제곱을 구하는 식을 만든다.
5. 홀수일 경우 위에서 반으로 나누어 계산한 값에서 베이스의 수를 하나 곱해 값을 도출한다.
6. 나머지 짝수일 경우에는 위에서 반으로 나누어 계산한 값을 그대로 사용한다.

## 소스코드

```
function power(base, exponent) {
  // 지수가 0일 경우 바로 1을 리턴.
  if (exponent === 0) return 1;

  const half = parseInt(exponent / 2);
  const temp = power(base, half);
  //temp * temp를 통해 코드 간결성을 높힘
  const result = (temp * temp) % 94906249;

  if (exponent % 2 === 1) return (base * result) % 94906249;
  else return result;
}
```

## 후기

시간복잡도에 따른 문제 풀이의 방향성을 찾기 힘들었다.
기본적으로 반복문을 통해 만들 수 있는 문제였지만 시간복잡도라는 것이 설정되어 있기 때문에
이를 해결하기 위해 반으로 나누어 간결하게 문제에 대한 로직을 구성하는 사고가 필요하다.