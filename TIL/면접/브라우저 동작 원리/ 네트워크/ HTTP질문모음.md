### **💡 브라우저 렌더링 (작동) 원리에 대해 설명하세요.**

> 브라우저 렌더링 원리는 크게 6단계로 나눌 수 있습니다.

HTTP 모듈 또는 파일 시스템으로 전달 받은 resource stream을 읽는 과정인 **1. Loading** 과정을 거치고, HTML 마크업을 처리하고 **2. DOM Tree를 빌드**하며, CSS 마크업을 처리하고 **3. CSSOM Tree를 빌드**합니다. 생성한 DOM 및 CSSOM 트리를 결합하여 **4. 렌더링 트리를 형성**하며, 렌더링 트리에서 각 노드의 형태를 계산하여 Box-Model을 생성하는 **5. Layout** 과정을 거치고, 개별 노드를 화면에 페인트하는 **6. Paint** 과정을 거쳐 렌더링이 이루어집니다.

### **💡 웹페이지가 사용자에게 보여지는 과정에 대해서 설명하세요.**

![https://images.velog.io/images/yeyo0x0/post/98f7c5fd-9e1f-4f9e-bb90-6232a00c956f/image.png](https://images.velog.io/images/yeyo0x0/post/98f7c5fd-9e1f-4f9e-bb90-6232a00c956f/image.png)

> 웹페이지는 다른 도메인 페이지로 이동하려고 할 때 발생하는 Prompt for unload 과정을 시작으로 Redirect부터 Response 까지의 과정에 해당하는 네트워크 통신 과정을 거칩니다.

세부적인 과정을 설명하면, 해당하는 URL로 HTTP 요청을 보내는 Redirect, 이미 캐싱된 응답을 확인하여 재사용하는 AppCache 과정을 거치고, DNS를 통해 도메인을 IP주소로 변환한 다음, IP 주소를 통해 TCP 통신으로 서버에 연결하여 Request, Response의 과정을 거칩니다. 응답을 받은 후에는 파일을 파싱하고 렌더링하는 Processing 과정을 거치고 마지막으로 화면에 보여주는 Load 과정을 수행합니다.

### **💡 Client Side Rendering 과 Server Side Rendering 의 차이에 대해서 설명하세요.**

![https://images.velog.io/images/yeyo0x0/post/f5981cd4-b22c-4568-b1a8-c856051b5cb0/image.png](https://images.velog.io/images/yeyo0x0/post/f5981cd4-b22c-4568-b1a8-c856051b5cb0/image.png)

> CSR은 웹 페이지의 렌더링이 클라이언트 측에서 일어나는 것이고, SSR은 서버 측에서 처리하는 방식입니다.

CSR의 경우 서버 부하가 줄고 페이지 이동에서 부드러운 UX를 제공할 수 있지만 초기 로딩 속도가 느리고, SEO(검색엔진 최적화)가 불가능 하다는 점과 쿠키를 사용해 사용자 정보 저장하여 보안적으로 위험 요소가 있습니다. SSR은 서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 보여주기 때문에 초기 로딩 속도가 빠르고, SEO 측면에서 유리하며, 서버에서 세션을 통해 사용자 정보를 저장할 수 있다는 장점이 있으나 화면 전환에서 서버 부담이 커진다는 단점이 있습니다.(View가 변경될 때마다 서버에 요청해야 하기 때문에)

### **💡 프론트엔드 입장에서 신경써야 할 보안은 어떤 것들이 있나요?**

> CSRF와 XSS 등이 있습니다.

CSRF는 사이트 간 요청 위조(cross site request forgery) 라는 의미로 다른 사이트에서 유저가 보내는 요청을 조작하는 것을 말합니다. 이러한 문제는 **referrer 검증**, **security token 사용**, **double submit cookie 검증** 등으로 해결 할 수 있습니다. XSS(cross site scripting)는 공격자가 상대방의 브라우저에 script를 실행할 수 있게 하여 사용자의 세션을 가로채거나 웹 사이트 변조, 악의적 컨텐츠 삽입, 피싱 공격 등을 하는 것으로 예방하기 위해서는 중요 정보를 쿠키에 저장하지 않고, 정규 표현식을사용해 태그 입력 필터를 설치하고, HTML 포맷의 입력을 제한하는 방법 등이 있습니다.

### **💡 SPA의 장점이 무엇인가요?**

> SPA는 Single Page Application의 약자로, 하나의 페이지로 구성된 애플리케이션을 말합니다.

SPA 장점으로는

1. 클라이언트가 모든 페이지를 가지고 있으므로 앱과 같은 자연스러운 사용자 경험을 제공합니다.
2. 페이지를 이동하더라도 필요한 부분만 교체하면 되므로 효율성이 증가합니다.
3. 서버 부담이 줄어듭니다.
4. 모듈화나 컴포넌트별 개발에 용이합니다.
5. 백엔드와 프론트엔드가 비교적 명확하게 구분됩니다.
6. 앱과 웹이 동일한 서버를 이용할 수 있습니다.
7. PWA(Progressive Web App)를 개발하기에도 좋다.

### **💡 lazy loading이 무엇인가요?**

> 사용자가 필요할 때 이미지를 로딩하는 방식으로 페이지에 보여지는 이미지들은 미리 로드하고 나머지 이미지들은 스크롤 이벤트가 발생했을 때에 로드하는 방식입니다. lazy loading을 통해 웹 성능을 향상시키고 통신 비용을 줄일 수 있습니다.

### **💡 웹페이지 redirect의 다양한 구현법에 대해서 설명하세요.**

> HTTP, HTML, Javscript를 통해 리다이렉트가 가능합니다.

HTTP 리다이렉트는 3으로 시작하는 상태코드(3xx)를 지닌 응답을 활용해 리다이렉트가 가능합니다. HTML 에서는 `<meta>` 태그와 `http-equiv` 속성을 통해 가능하지만`<meta http-equiv="refresh" content="지연시간;url=이동할사이트주소" />`브라우저의 뒤로가기 버튼이 원하는 대로 동작하지 않기 때문에 지양해야 하는 방법입니다. Javascrip에서는 `window.location` 코드를 통해 리다이렉트가 가능합니다.

### **💡 Reflow가 발생하는 이유와 방지 방법은 무엇인가요?**

> Reflow는 브라우저 렌더링을 위해 DOM 트리를 그리는 과정에서 발생합니다.

예를 들어 노드의 추가 혹은 제거, 요소의 위치나 크기 변경, 폰트 변경, 페이지 초기 렌더링 시나 윈도우 리사이징 시 reflow가 발생합니다. Reflow를 최적화하는 방법은 1. 클래스 변화에 따른 스타일 변경 시, 최대한 말단에 위치한 노드에 적용하는 방법 2. 인라인 스타일을 배제하는 방법 3. 애니메이션이 들어간 노드에 position 속성을 `fixed`나 `absolute`로 지정하여 전체 노드에서 분리시키는 방법 등이 있습니다. => 전체 노드가 아닌 변경이 필요한 노드에만 repaint가 발생하도록 할 수 있음.

### **💡 [연관질문] 어떤 방식을 실제로 써서 reflow를 방지해봤는지.**

ligthhouse 등도 활용해서 해결해 본 경험이 있으면 좋음.

### **💡 디자인 패턴이란 무엇이고 각각의 장단점에 대해서 설명하세요.**

> 디자인 패턴은 소프트웨어 설계 시 기존 환경에서 반복적으로 일어나는 문제들을 풀어나갈 수 있는 일종의 솔루션 입니다. 디자인 패턴은 크게 생성 패턴, 구조 패턴, 행동 패턴으로 구분할 수 있습니다. 생성 패턴 : 객체의 생성절차를 추상화하는 패턴. <ex) 싱글톤, 추상 팩토리, 프로토타입> 구조 패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴. <ex) 어댑터, 데코레이터> 행동 패턴 : 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴. <ex) 커맨드, 인터프리터, 메멘토, 옵저버, 템플릿 메소드 등>

### **💡 OSI 7계층에 대해 설명해주세요.**

> OSI 7 계층은 ISO(국제표준화기구)에서 네트워크 통신 과정을 7단계로 정의한 표준 규약 네트워크입니다. 7단계로 나눔으로써 문제가 생겼을 때 빠르게 파악할 수 있다는 장점이 있습니다.

7계층은 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 이루어져 있습니다.

1. 물리 계층 : 장비를 가동시키기 위한 전기 공급부터 장비끼리의 물리적인 연결을 위한 랜케이블 등을 포함합니다. ex) 광케이블, 전선, 모뎀
2. 데이터 링크 계층 : 물리계층의 물리적인 링크를 이용해 데이터를 신뢰성있게 전송하는 계층입니다. MAC 주소로 통신합니다. ex) 브릿지, 스위치, 이더넷
3. 네트워크 계층 : IP를 기반으로 데이터가 들어있는 패킷을 이용해 데이터 전송 경로를 결정합니다.
4. 전송 계층 : 데이터 전송에 대한 전반적인 조율을 담당하며 TCP/UDP 포트 정보를 참조해 데이터를 전송하고 통신의 신뢰성을 보장할 수 있습니다.
5. 세션 계층 : 통신 시스템 사용자간의 연결을 유지하거나 설정합니다. ex) TLS, SSH
6. 표현 계층 : 데이터를 빠르고 안전하게 전송하기 위한 압축, 암/복호화 작업을 하는 계층입니다. ex) JPEG, MPEG
7. 응용 계층 : 데이터를 최종 사용자가 확인하는 마지막 단계입니다. ex) HTTP 프로토콜

### **💡 TCP와 UDP 방식의 차이점을 설명해주세요.**

> TCP와 UDP 모두 IP 프로토콜을 기반으로 구현되어 있지만 TCP는 연결형 서비스이며 UDP는 비연결형 서비스입니다. TCP는 연결이 성공해야 통신이 가능하며 데이터의 전송 순서를 보장하기 때문에 신뢰성이 있지만 UDP보다 전송속도가 느립니다. UDP는 연결 없이 통신이 가능하며 데이터 전달이나 전송 순서가 보장되지 않아 신뢰성이 없지만 TCP보다 전송속도가 빠릅니다.

### **💡 [연관질문] TCP의 3 Way-HandShake와 4 Way-HandShake에 대해서 알고 있나요?**

> 3 way handshake는 통신을 시작할 때 거치는 과정으로 패킷 내부의 값을 확인하여 클라이언트와 서버가 서로 보낸 패킷의 순서와 패킷을 제대로 받았는지 확인할 수 있습니다. 이 과정에서 총 3번의 통신이 필요하기 때문에 3 way handshake라고 합니다. 또한 4 way-handshake는 클라이언트와 서버 간의 연결된 세션을 종료하기 위해 수행하는 절차이며 총 4번의 통신이 필요합니다.

**3 way handshake** 클라이언트가 서버에 접속을 요청하는 SYN 패킷 전송 –> <– 서버는 클라이언트에게 요청을 수락한다는 ACK와 SYN 플래그가 설정된 패킷 전송 클라이언트는 서버에게 ACK 전송 –> (연결이 이루어짐)

**4 way-handshake** 클라이언트가 연결을 종료하겠다는 FIN 플래그 전송 –> <– 서버는 확인 메시지 전송 후 자신의 통신이 끝날 때까지 기다림( TIME_WAIT) <– 서버가 통신이 끝났으면 연결이 종료되었다고 FIN 플래그 전송 클라이언트는 확인 메시지 전송 –>

### **💡 DNS에 대해 설명해주세요.**

> Domain name system으로 www.example.com과 같은 Host의 도메인 네임을 Host의 IP로 변환해주는 서비스를 말합니다.

DNS 서비스 과정

1. 웹 브라우저에 도메인 입력 시 local DNS 서버에게 해당하는 IP 주소 query.
2. local DNS 서버는 확인하여 없으면 root DNS 서버 정보를 전달
3. Root DNS 서버에 도메인명을 query 하면 `com`과 같은 최상위 도메인을 인식하여 이를 관리하는 TLD(Top-level-domain) 서버 정보 전달
4. TLD에 도메인명 query 하면 최상위 도메인과 서브 도메인(naver.com) 인식하여 이를 관리하는 DNS 서버(Authoritative 서버) 정보 전달
5. Local DNS 서버가 **[Authoritative DNS 서버](https://ye-yo.github.io/%EB%A9%B4%EC%A0%91/2022/03/15/interview4.html#authoritative-dns-server)**에 도메인명 전달하면 전체 도메인 네임에 해당하는 IP 주소 전달
6. local DNS 서버는 이 IP 주소를 host에게 넘겨줌.

### **Authoritative DNS Server**

> 실제 개인 도메인과 IP 주소의 관계가 기록/저장/변경되는 서버. 일반적으로 도메인/호스팅 업체의 ‘네임서버’를 말하지만, 개인 DNS 서버 구축을 한 경우에도 여기에 해당한다.

### **💡 프록시 서버가 필요한 이유에 대해 설명해주세요.**

> 프록시 서버는 클라이언트가 다른 네트워크에 접속할 수 있도록 중간에서 대리인 역할을 하는 서버로 대표적으로 캐시 데이터를 사용하거나 보안 목적 또는 접속을 우회하기 위해 사용합니다.

프록시 서버는 프록시 서버에 요청된 내용들을 캐시를 이용해 저장할 수 있으며 이를 통해서 전송 시간을 절약하고 외부 트래픽을 줄일 수 있습니다. 또한 프록시 서버를 사용할 경우 클라이언트가 직접 접속하지 않기 떄문에 IP를 숨기는 것이 가능하며 프록시 서버를 방화벽으로서 사용할 수도 있기 때문에 보안 목적으로 사용하기도 합니다. 또한 클라이언트의 접속이 제한되는 경우 이를 우회하기 위해 사용하기도 합니다. (ex: 국가 제한, CORS 정책 제한 등)

## \***\*HTTP\*\***

---

### **💡 Http와 Https 통신 방식의 차이에 대해 설명해주세요.**

> HTTP(Hypertext Transfer Protocol)는 서버와 클라이언트가 데이터를 주고받을 때 사용하는 프로토콜로 데이터 전송 시 정보가 암호화되지 않는다는 문제가 있었습니다. 이를 해결하기 위해서 HTTP에 SSL을 사용한 HTTPS가 등장하였고 HTTPS는 SSL 인증서를 통해 데이터를 암호화합니다. 또한 HTTP는 80번 포트로 통신하며 HTTPS는 443포트로 통신하는 차이가 있습니다.

### **💡 HTTP 프로토콜에 대해 설명해주세요.**

> HTTP 프로토콜은 서버와 클라이언트가 데이터를 주고받을 때 사용하는 프로토콜입니다. 무상태성과 비연결성이라는 특성을 가지고, 단순하고 확장이 가능하다는 특징도 있습니다.

### **💡 [연관질문] 무상태와 비연결성에 대해 설명해주세요.**

> 두가지 모두 HTTP의 특성으로, 무상태성은 HTTP가 요청 메시지를 보내기 직전까지 대상 컴퓨터가 연결이 가능한지, 메시지를 응답할 수 있는 상태인지 알 방법이 없는 것을 말하며, 비연결성은 클라이언트와 서버가 한 번 연결을 맺은 후 서버가 응답을 마치면 맺었던 연결을 끊어버리는 것을 말합니다. HTTP는 연결을 유지하기 위한 리소스를 줄여 더 많은 연결을 하기 위해 비연결성을 갖습니다.

- 비연결성을 해결하기 위한 버전별 차이가 있음.

### **💡 REST API에 대해 설명해주세요.**

> HTTP를 활용하는 규칙을 정하기 위해 등장한 소프트웨어 프로그램 아키텍처의 한 형식입니다. HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미합니다.

- REST(Representational State Transfer) _ REST API vs GraphQL 차이점 _ REST API와 관련된 성숙도 모델

### **💡 GET 메서드와 POST 메서드의 차이점에 대해 설명해주세요.**

> GET은 동일한 연산을 여러 번 수행하더라도 동일한 결과가 나타나야 한다는 멱등성을 가지고 있고 조회 시에 사용됩니다. POST는 여러 번 수행하더라도 응답은 다를 수 있으며 데이터를 생성/업데이트하기위해 데이터를 전송 시킬 때에 사용됩니다.

### **💡 PUT 메서드와 PATCH 메서드의 차이점에 대해 설명해주세요.**

> 둘다 데이터 수정을 위한 메소드이지만, PUT 요청 시 일부분만 보낼 경우 나머지는 default 값으로 수정되므로 바뀌지 않는 속성들도 모두 보내야 합니다. PATCH는 바뀌는 데이터만 보내면 나머지는 기존 데이터가 유지됩니다.

=> 전체 수정에는 put, 일부 수정은 patch 사용

### **💡 Expires, Date, Age, If-Modified-Since의 차이점에 대해 설명해주세요.**

전부 캐시된 데이터의 만료를 체크하기 위해 사용됩니다.

> Expires : 응답 컨텐츠의 만료 일자

- Age : max-age 시간 내에서 얼마나 흘렀는지 초 단위로 나타냄.
- Date : 그 객체가 원서버에서 최초로 생겨난 일시. 변경해서는 안됨.
- If-Modified-Since : 최근 변경일자.

### **💡 If-Modified-Since와 If-None-Match의 차이점에 대해 설명해주세요.**

> 두가지 모두 HTTP 요청헤더의 한 종류이며 캐시의 유효성을 확인할 수 있는 것으로, If-Modified-Since는 최근 변경일자를 의미하고 이 날짜와 최근 변경일의 날짜를 비교하여 요청을 처리합니다. If-None-Match는 문서에 대한 일련번호 같은 태그를 제공하여 캐시된 태그가 현재 문서 태그와 동일한지를 체크하는 것입니다.

- 별도 보충 정리

### **💡 브라우저 저장소에 대해서 설명해주세요.**

> 브라우저 저장소에는 Cookie와 Web Storage가 있습니다. Cookie와 Web storage 모두 해당 도메인과 관련된 데이터를 클라이언트 웹 브라우저에 저장할 수 있도록 해줍니다.

Cookie는 매번 서버로 전송되고 문자열만 가능하며, 용량의 제한이 있고, 만료일자가 존재합니다.

Web Storage는 서버로 전송되지는 않으며 문자열 외에도 구조화된 객체를 저장할 수 있으며 용량이 제한되어있지 않고 만료일자가 없습니다.

Web Storage로는 LocalStorage와 SessionStorage가 있는데 LocalStorage는 데이터를 지우지 않는한 영구 보관이 가능하며 도메인만 같다면 전역적으로 데이터 공유가 가능합니다. SessionStorage는 브라우저가 닫힐 경우 데이터가 사라지며 같은 사이트의 도메인이더라도 브라우저가 다르면 서로 다른 영역이 됩니다.

### **💡 HTTP 상태 코드에 대해서 설명하세요.**

> 웹 서비스의 상태를 나타내는 코드입니다. 3자리 숫자로 이루어져 있으며 첫번째 자리는 1~5까지 제공됩니다.

- 1xx : 서버가 요청을 받았으며 작업을 계속 진행하라는 의미입니다.
- 2xx : 요청을 성공적으로 받았다는 의미
- 3xx : 요청 완료를 위해 추가작업 조치가 필요하다는 의미 `ex) 304: not modified 응답이 수정되지 않아서 캐시를 사용하겠다는 의미`
- 4xx : 오류가 발생하였다는 의미로 대표적으로 요청받은 리소스를 찾을 수 없다는 의미의 404 에러가 있습니다.
- 5xx : 서버 측의 오류로 예로는 응답을 시간 내에 받지 못해 발생하는 504 오류가 있습니다. `ex) 502는 bad gateway 게이트 웨이로부터 잘못된응답 수신`

### **💡 CORS에 대해 설명해주세요.**

> CORS(Cross-Origin Resource Sharing)는 교차 출처 리소스 공유라는 의미로 추가 HTTP 헤더를 사용하여 한 출처에서 다른 출처의 자원에 접근할 수 있는 권한을 부여하도록 브라우저에게 알려주는 체제입니다.

> 💡 [연관질문] CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가요? 어떤 옵션을 통해서 해결하셨나요?

> 💡 Preflight Request에 대해 설명해주세요.

> 💡 same-origin 정책에 대해 설명해주세요.

> 💡 로컬과 실제 환경 배포할 때의 CORS 세팅에 있어서 주의해야 할 점에 대해 설명해주세요.

### **💡 SSL 인증서 암호화 기법인 대칭키 암호화 기법, 공개키 암호화 기법에 대해 설명해주세요.**

> 대칭키 암호화는 클라이언트와 서버가 동일한 키를 사용해 암/복호화를 진행하는 기법이고 공개키 암호화 기법은 1개의 쌍으로 구성된 공개키와 개인키를 각각 암호화/복호화 시에 사용하는 기법으로 모두에게 공개되는 공개키로 암호화하고 개인만이 알고 있는 개인키로만 복호화가 가능합니다.

대칭키 암호화 기법은 키가 노출되면 위험하지만 연산 속도가 빠르며, 비대칭키 암호화 기법은 공개키가 노출되더라도 개인키로만 복호화가 가능하기 때문에 안전하며 대칭키보다 연산 속도가 느리다는 단점이 있습니다.

### **💡 OAuth에 대해서 간단히 설명해주세요.**

> OAuth 2.0은 인증을 위한 표준 프로토콜의 한 종류로, 보안된 리소스에 액세스하기 위해 클라이언트에게 권한을 제공하는 과정을 단순화한 프로토콜 중 하나입니다. SNS 로그인이 이에 해당합니다.

OAuth는 편리하게 사용자 인증이 가능하다는 장점이 있으며 인증 정보를 입력하는 것보다 보안상으로 안전한 방식입니다.

### **💡 Session과 Cookie, Token, 그리고 Web Storage의 차이에 대해 설명해주세요.**

> session은 서버에 저장되고 클라이언트 구분을 위해 세션 ID를 부여하며 브라우저가 종료될 때까지 유지됩니다. 이에 반해 쿠키는 브라우저에 저장되며 만료기한 설정이 가능합니다. session은 객체 형태로 저장되고 쿠키는 문자열 형태로 저장됩니다. 또한 세션은 서버에 데이터가 저장되기 때문에 쿠키보다 보안면에서 우수하지만 쿠키보다 요청속도가 느리다는 차이가 있습니다. Token은 사용자 인증 정보를 담고 있는 것으로 대표적으로 JWT(JSON Web Token)이 있습니다. 토큰은 객체 형태로 저장되며 만료기한 설정이 가능하고 웹 스토리지, 쿠키 등에 저장됩니다. Web storage는 쿠키와 유사하게 브라우저에 저장되며 문자열 형태로 저장되지만 Web Storage는 용량 제한이나 만료 기한 설정이 따로 없으며 쿠키는 매번 서버 요청시에 포함되어 전달되지만 Web Storage는 전달되지 않는다는 점에서 차이가 있습니다.

- 로그인 기능을 예로 들어서 설명하기

### **💡 SPA의 장점이 무엇인가요?**

> SPA는 Single Page Application의 약자로, 하나의 페이지로 구성된 애플리케이션을 말합니다.

SPA 장점으로는

1. 클라이언트가 모든 페이지를 가지고 있으므로 앱과 같은 자연스러운 사용자 경험을 제공합니다.
2. 페이지를 이동하더라도 필요한 부분만 교체하면 되므로 효율성이 증가합니다.
3. 서버 부담이 줄어듭니다.
4. 모듈화나 컴포넌트별 개발에 용이합니다.
5. 백엔드와 프론트엔드가 비교적 명확하게 구분됩니다.
6. 앱과 웹이 동일한 서버를 이용할 수 있습니다.
7. PWA(Progressive Web App)를 개발하기에도 좋다.

### **💡 웹페이지 redirect의 다양한 구현법에 대해서 설명하세요.**

> HTTP, HTML, Javscript를 통해 리다이렉트가 가능합니다.

HTTP 리다이렉트는 3으로 시작하는 상태코드(3xx)를 지닌 응답을 활용해 리다이렉트가 가능합니다. HTML 에서는 `<meta>` 태그와 `http-equiv` 속성을 통해 가능하지만`<meta http-equiv="refresh" content="지연시간;url=이동할사이트주소" />`브라우저의 뒤로가기 버튼이 원하는 대로 동작하지 않기 때문에 지양해야 하는 방법입니다. Javascript에서는 `window.location` 코드를 통해 리다이렉트가 가능합니다.

### **💡 TCP와 UDP 방식의 차이점을 설명해주세요.**

> TCP와 UDP 모두 IP 프로토콜을 기반으로 구현되어 있지만 TCP는 연결형 서비스이며 UDP는 비연결형 서비스입니다. TCP는 연결이 성공해야 통신이 가능하며 데이터의 전송 순서를 보장하기 때문에 신뢰성이 있지만 UDP보다 전송속도가 느립니다. UDP는 연결 없이 통신이 가능하며 데이터 전달이나 전송 순서가 보장되지 않아 신뢰성이 없지만 TCP보다 전송속도가 빠릅니다.

### **💡 OAuth에 대해서 간단히 설명해주세요.**

> OAuth 2.0은 인증을 위한 표준 프로토콜의 한 종류로, 보안된 리소스에 액세스하기 위해 클라이언트에게 권한을 제공하는 과정을 단순화한 프로토콜 중 하나입니다. SNS 로그인이 이에 해당합니다.

OAuth는 편리하게 사용자 인증이 가능하다는 장점이 있으며 인증 정보를 입력하는 것보다 보안상으로 안전한 방식입니다.
