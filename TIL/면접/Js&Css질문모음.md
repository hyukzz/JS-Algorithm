# css&js

1. CSS보다 SCSS/SASS가 가진 장점에 대해 설명하세요.

   SCSS와 SASS는 CSS보다 쉬우면서, 추가 기능이 있는 CSS의 확장판 같은 역할입니다. 코드 중복을 줄일 수 있고, 변수를 사용할 수 있습니다. 이러한 장점은 코드를 쉽게 관리할 수 있게 하여 유지보수성을 극대화합니다.

2. CSS, SCSS, SASS의 차이점과 리액트와 사용할 거면 무엇을 쓸 건지 설명하세요.

   css와 SASS/SCSS의 차이점은 변수, 함수, 연산자를 만들어 사용할 수 있습니다. **SASS와 SCSS의 차이점은** 문법 차이가 있습니다. SCSS는 CSS 문법을 따라가기 때문에 세미콜론을 사용해야 합니다. 반면 SASS는 세미콜론을 사용하지 않습니다. 리액트와 사용할 경우에는 사용성에 있어서는 큰 차이가 없기 때문에, 나에게 익숙한 CSS 문법을 사용하는 SCSS를 사용할 것입니다.

3. id와 class 셀렉터의 차이점에 대해 설명하세요.

   id는 문서 안의 유일한 요소를 식별하고 싶을 때 사용하며, class는 공통점이 있는 여러 요소를 그룹화하여 식별하고 싶을 때 사용합니다.

4. CSS 박스 모델에 대해서 설명하세요.

   모든 HTML 요소는 박스 모양으로 구성되기 때문에, 이를 박스 모델이라고 합니다.

   박스 모델에서는 각 HTML 요소들에 padding, border, margin, content이 있습니다.

   - content: 박스의 실질적 내용으로, 텍스트나 이미지 등 요소의 실제 내용이 들어간다.
   - padding: content와 border 사이에 있는 안쪽 여백이다.
   - border: content와 padding을 감싸는 테두리이다.
   - margin: border를 기준으로 이웃하는 요소 사이의 간격이다.

5. CSS에서 px, em, rem, vh, vw 단위들의 차이점은 무엇인가요?

   길이를 나타내는 단위는 **절대 길이 단위**와 **상대 길이 단위**로 나뉩니다. px는 절대 길이 단위로, 일반적인 모니터 디스플레이의 1 픽셀을 의미합니다. 나머지는 상태길이입니다.

6. CSS 레이아웃 기법의 종류와 특징에 대해서 설명하세요. (grid, flexbox)

   grid는 테이블처럼 세로 열과 가로 행을 기준으로 요소를 정렬합니다. 하지만 테이블에 비해 Grid는 더 다양한 레이아웃을 구현할 수 있습니다.

   flexbox는 인터페이스 내 아이템 간 공간 배분과 정렬 기능을 제공하기 위한 1차원 레이아웃 모델로 설계되었습니다. X축 또는 Y축 방향으로 요소를 배치, 정렬할 수 있으며, 각 요소의 순서를 변경할 수 있기 때문에, 기존 CSS 레이아웃 기술에 비교했을 때, 손쉽게 멀티 스크린에 대응할 수 있습니다.

   CSS 레이아웃 기법에는 크게 Flexbox와 grid 두 가지가 있습니다. flexbox는 인터페이스 내 아이템 간 공간 배분과 정렬 기능을 제공하기 위한 1차원 레이아웃 모델로 설계되었습니다. X축 또는 Y축 방향으로 요소를 배치, 정렬할 수 있어서 각 요소의 순서를 변경할 수 있습니다. 그렇기 때문에 기존 CSS 레이아웃 기술에 비교했을 때 손쉽게 멀티스크린에 대응할 수 있습니다. grid는 테이블처럼 세로 열과 가로 행을 기준으로 요소를 정렬합니다. 그러나 테이블에 비해 grid는 더 다양한 레이아웃을 구현할 수 있습니다. 행과 열 격자 구조에 요소를 자유롭게 배치할 수 있고, HTML 문서 위계 구조와 무관하게, grid 인터페이스 내부에 포함된 자식 아이템을 Grid 내부에 자유롭게 위치시킬 수 있습니다.

7. CSS in JS(styled component)의 장단점에 대해서 설명하세요.

   장점으로는 **CSS in JS를 사용하면 CSS가 컴포넌트 단위로 추상화되기 때문에 CSS 파일 간에 의존성을 신경쓰지 않아도 됩니다. 또한 CSS가 컴포넌트 스코프에서만 적용되기 때문에, 우선순위 문제가 발생하지 않습니다. 하지만 단점으로는 번들의 크기가 커져 다운로드 시간이 길어지기 때문에 사용자에게 first view를 보여주기까지 시간이 오래 걸리며, 이는 사용자 경험에 안 좋은 영향을 끼칩니다.**

8. position 속성과 z-index의 연관성에 대해 설명하세요.

   position 속성과 z-index 값이 있으면 z-index 값이 큰 태그가 위에 쌓이고, z-index 값이 커도 부모 태그의 z-index가 우선됩니다.

9. event loop에 대해서 설명하세요.

   **실제 자바스크립트가 구동되는 환경(브라우저, Node.js등)에서는 주로 여러 개의 스레드가 사용되는데, 이러한 구동 환경이 단일 호출 스택을 사용하는 자바 스크립트 엔진과 연동하기 위해 사용되는 장치가 바로 '이벤트 루프' 입니다. 이벤트 루프는 call stack이 비어있는 경우, task queue에서 대기하던 callback을 call stack으로 옮겨서 callback을 실행시켜주는 역할을 합니다.**

10. callback, promise, async/await 의 특징과 차이점에 대해서 설명하세요.

    callback은 코드 가독성 측면에서 문제가 많았습니다. callback은 함수에 담아서 사용해야 하기 때문에, 함수가 연속적으로 반복되어 직관적이지 않은 단점이 있습니다. 이를 해결하기 위해서 Promise가 새롭게 등장했는데, Promise 는 비동기 코드를 간편하게 처리할 수 있게 도와주는 자바스크립트의 객체입니다. Promise 역시 하나의 비동기 작업을 처리하기에는 무리가 없었으나, 연속되는 비동기 작업이 순서대로 작동되어야 하는 경우 callback hell 처럼 "promise hell"이 발생하였기 때문에, .then으로 chaining을 하기 보다는 기존에 쓰던 함수처럼 사용하고 싶어 나온게 async/ await입니다. 동기적으로 작동하는 것처럼 Promise를 조금 더 쉽게 다룰 수 있게 만들어진 문법적 설탕입니다.

11. Blocking과 Non-Blocking의 차이점은 무엇인가요?

    Blocking은 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고, 호출한 함수가 대기하도록 합니다. 예를 들어 실행하는데 10초가 걸리는 A 라는 함수가 실행되면 B라는 함수가 실행되려면 10초간 대기해야 합니다. Non-Blocking은 호출된 함수가 할 일을 마치지 않았더라도 바로 제어권을 내주어 호출한 함수가 다른 일을 진행할 수 있는 것입니다. 예를 들어, A함수가 종료되지 않은 상태여도 바로 B함수를 실행할 수 있습니다.

12. Synchronous execution과 Asynchronous execution의 차이점은 무엇인가요?

    Synchronous execution은 한 작업이 끝남과 동시에 다음 작업이 실행되는 실행 방식을 의미합니다. 예를 들어, 함수 A가 실행이 완료되자마자 함수 B가 연속으로 실행되었다면 이것은 동기적 실행입니다.

    Asynchonous execution은 한 작업이 끝나기 전에 다른 작업을 수행할 수 있습니다. 예를 들어, 함수 A가 실행중인데, 함수 B가 실행되었다면 이는 비동기적 실행입니다.

13. nodejs는 싱글쓰레드인가요?

    Node.js 자체는 싱글스레드 방식이 아닙니다. 싱글 스레드 방식으로 동작하는 것은 Node.js나 브라우저가 아니라 브라우저에 내장된 자바스크립트 엔진입니다. 만약 모든 자바스크립트 코드가 자바스크립트 엔진에서 싱글 스레드 방식으로만 동작한다면 자바스크립트는 비동기로 동작할 수 없을 것입니다. 즉, 자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저나 Node.js는 멀티 스레드로 동작하는 것입니다. 자바스크립트를 실행하는 부분에서만 싱글스레드로 구성되어있고, 이 때의 작업 동시성은 이벤트 루프를 통해서 구현할 수 있습니다.

14. nodejs는 event-driven architecture 인가요?

    event-driven architecture은 시시각각 발생하는 이벤트의 생성과 감지, 소비 및 시스템 상태의 중대한 변화를 지원하는 소프트웨어의 모델 혹은 아키텍처 패러다임을 의미합니다.

    Node.js에는 HTML 요소가 없기 때문에 대부분의 event는 프로세스, 네트워크, 파일과의 상호 작용 등에서 비롯 됩니다. 따라서 Node.js 는 event-driven architecture라 할 수 있습니다.

15. this와 dynamic scoping에 대해서 설명하세요.

    this는 **자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수**를 뜻합니다. **this를 통하여** 자신이 속한 객체 또는 **자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조** 할 수 있습니다.

    dynamic scoping은 함수를 호출하는 위치가 아닌, **어디서 호출했는지에 따라서 동적으로 상위 스코프를 결정**하는것을 볼수 있습니다. 이러한 방식을 **dynamic scope**라고 부릅니다.

16. 객체 지향 프로그래밍이란 무엇인가요?

    객체 지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말합니다.

17. Prototype Chaining이란 무엇인가요?

    Prototype Chaining은 기존에 존재하는 객체를 기반으로 새로운 객체를 생성할 때 사용됩니다. 만약 객체의 프로퍼티에 접근하려고 할때, **프로퍼티가 없다면, `__proto__` 접근자 프로퍼티를 따라서 본인의 부모 역할을 하는 객체를 순차적으로 돌아다니며 검색**합니다. **Prototype Chaning의 최상위 객체는Object.prototype**이며, 해당 객체의 프로퍼티, 메소드는 모든 객체에게 상속됩니다.

18. IIFE란 무엇이며 언제 사용하나요?

    함수 정의와 동시에 즉시 호출되는 즉시 실행 함수를 의미합니다. Javascript에서는 함수가 어떻게 정의되었는지 혹은 어떻게 호출되었는지에 따라서 scope가 정해지게 됩니다.이를 활용하여 변수나 메소드가 접근되는 것을 closure가 보호해줄 수 있는데 이를 private scope라 하며 주로 이런 상황에 IIFE가 사용됩니다.

19. setTimeout 에서 this는 왜 전역을 가리키는지 설명하세요.

    setTimeOut()에 의해 실행된 코드는 별도의 실행 컨텍스트에서 setTimeOut이 호출된 함수로 호출되어집니다. this는 함수의 호출 방식에 의해서 결정되기에 this를 호출된 함수에서 설정 혹은 할당하지 않는 경우, non-strict모드에서는 전역(혹은 window) 객체, strict 모드에서는 undefined를 기본 값으로 합니다. 그렇기에 setTimeOut함수를 이용해서 window객체나 undefined가 출력되는 에러를 볼 수 있습니다. 이 방법을 해결하기 위해서는 3가지 해결책이 있습니다. 첫번째로는 this 설정이 필요한 곳을 함수로 감싸주고, 두번째는 화살표 함수로 작성하는 방법입니다. 마지막인 세번째는 bind를 활용해서 this를 지정해주면 됩니다.

20. 스택과 힙의 차이에 대해서 설명하세요.

    **콜 스택(call stack) 영역에는** 원시타입(숫자 등) 데이터가 저장됩니다.

    **메모리힙(memory heap) 영역에는** 참조타입(배열, 객체, 함수 등) 데이터가 저장됩니다. 즉 참조타입 데이터를 선언을 하게 되면 해당 주소값만 콜 스택에 저장되고 주소값에 따른 value는 힙에 저장됩니다.

21. call-by-value에 대해서 설명하세요.

    call-by-value는 함수 호출 방식 중 하나입니다. 값에 의한 호출이라고 불러집니다. 기본적으로 자바스크립트는 원시값을 argument로 넘겨주면 call-by-value의 형태로 작동합니다. 더 자세히 설명드리자면 함수를 호출하면 argument로 값이 넘어오게 됩니다. 여기서 argument는 함수의 변수에 집어넣는 값을 의미합니다. 그 값은 복사된 값으로 넘어오게 되고 복사되었기에 해당 인자를 변형시켜도 영향을 받지 않습니다. 그렇기에 기존 정의 된 인자를 출력한다면 값이 바뀌지 않다는 것을 확인할 수 있습니다.
